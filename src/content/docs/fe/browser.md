---
title: "Browser"
description: "record for browser"
---

## 渲染过程

1、构建DOM树，渲染引擎解析HTML文档，将标签转换为DOM中的DOM节点，生成内容树

2、构建渲染树，解析对应的CSS样式文件，构建渲染树，不包含隐藏的节点

3、布局渲染树，从根节点递归调用，计算每一个元素的大小、位置，给出每一个节点在屏幕上的精确坐标

4、绘制渲染树，遍历渲染树，使用UI层来绘制每个节点

## 垃圾回收机制

### 方式

#### 引用法

> 就是判断一个对象的引用数，引用数`为0`就回收，引用数`大于0`就不回收。

在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引 用计数方式进行垃圾回收。

引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该
变量的时候这个值的引用次数就加 1 ，如果该变量的值变成了另外一个，则这个值得引用次数
减 1 ，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此
可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间

在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过
引用计数回收垃圾的，也就是说只要涉及 BOM 及 DOM 就 会出现循环引用问题

#### 标记法

> 标记法就是，将`可达`的对象标记起来，`不可达`的对象当成垃圾回收。

从初始的`根对象（window或者global）`的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。

那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。
